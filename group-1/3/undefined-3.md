# π£ λ§ν¬λ“ λ¦¬μ¤νΈ : μ΄λ΅ 



* μ—°κ²°λ¦¬μ¤νΈ : μ°¨λ΅€λ΅ μ—°κ²°λ λ…Έλ“λ¥Ό ν‘ν„ν•΄μ£Όλ” μλ£κµ¬μ΅°
* λ‹¨λ°©ν–¥ μ—°κ²°λ¦¬μ¤νΈ : κ°λ³„ λ…Έλ“ β΅οΈ λ‹¤μ λ…Έλ“
* μ–‘λ°©ν–¥ μ—°κ²°λ¦¬μ¤νΈ : κ°λ³„ λ…Έλ“ β΅οΈ λ‹¤μ λ…Έλ“ & μ΄μ „ λ…Έλ“



* β­οΈ μ‹μ‘ μ§€μ μ—μ„μ μ•„μ΄ν… μ¶”κ°€ λ° μ‚­μ  μ—°μ‚°μ΄ μƒμ μ‹κ°„ μ†μ”



### 1. Creating a Linked List

* λ‹¨λ°©ν–¥ μ—°κ²°λ¦¬μ¤νΈ κµ¬ν„ μ½”λ“

```java
class Node {
 Β Node next = null;
 Β int data;
 Β public Node(int d) {
 Β  Β data = d;
  }
 Β void appendToTail(int d){
 Β  Β Node end = new Node(d);
 Β  Β Node n = this;
 Β  Β while(n.next != null){
 Β  Β  Β n = n.next;
 Β   }
 Β  Β n.next = end;
  }
}
```

* λ‹¨λ°©ν–¥ μ—°κ²°λ¦¬μ¤νΈμ—μ„μ κ³ λ ¤μ‚¬ν•­ : `head` κ°€ λ°”λ€λ©΄ μ–΄λ–»κ² λλ”κ°€?
  * π‘‰ _`head` κ°€ λ°”λ€μ—μμ—λ„ μ–΄λ–¤ κ°μ²΄λ” `head`λ¥Ό κ³„μ† κ°€λ¦¬ν‚¤κ³  μμ„ μλ„ μλ‹¤._
  * `Node` ν΄λμ¤λ¥Ό ν¬ν•¨ν•λ” `LinkedList` ν΄λμ¤λ¥Ό λ§λ“ λ‹¤.(`head Node` λ³€μμ— headλ¥Ό κ°€λ¦¬ν‚¤λ” κ°’ μ €μ¥)





### 2. Deleting a Node from a Singly Linked List

* μ‚­μ  λ…Έλ“ : n
  1. `prev.next` λ¥Ό `n.next` λ΅ μ—°κ²°ν•λ‹¤.
  2. (μ–‘λ°©ν–¥ μ—°κ²°λ¦¬μ¤νΈμΌ κ²½μ°) `n.next.prev` λ¥Ό `n.prev` λ΅ μ—°κ²°ν•λ‹¤.



* β οΈ λ©”λ¨λ¦¬ κ΄€λ¦¬κ°€ ν•„μ”ν• μ–Έμ–΄λ¥Ό μ‚¬μ©ν•΄ κµ¬ν„ν•λ” κ²½μ°μ—λ” μ‚­μ ν• λ…Έλ“μ— ν• λ‹Ήλμ—λ λ©”λ¨λ¦¬κ°€ μ λ€λ΅ λ°ν™λμ—λ”μ§€ ν™•μΈ ν•„μ”!



* λ…Έλ“ μ‚­μ  μ½”λ“

```java
Node deleteNode(Node head, int d) {
 Β Node n = head;
 Β if (n.data == d) {
 Β  Β return head. Next;
  }
 Β 
 Β while (n.next != null) {
 Β  Β if (n.next.data == d) {
 Β  Β  Β n.next = n.next.next;
 Β  Β  Β return head;
 Β   }
 Β  Β n = n.next;
  }
 Β return head;
}
```

###

### 3. The "Runner" Technique

* Runner : μ—°κ²°λ¦¬μ¤νΈλ¥Ό μνν•  λ• λ‘ κ°μ ν¬μΈν„°λ¥Ό λ™μ‹μ— μ‚¬μ©ν•λ‹¤.
* ν• ν¬μΈν„°κ°€ λ‹¤λ¥Έ ν¬μΈν„°λ³΄λ‹¤ μ•μ„λ„λ΅ ν•κ³  ν¬μΈν„°λ¥Ό μ›€μ§μΌ λ• μ§€μ •λ κ°μ νΉμ€ μ—¬λ¬ λ…Έλ“λ¥Ό ν•λ²μ— μ›€μ§μΌ μ μλ„λ΅ μ„¤μ •ν•λ‹¤.



### 4. Recursive Problems

* μ—°κ²°λ¦¬μ¤νΈ λ¬Έμ  β‰’ μ¬κ·€ νΈμ¶
* β οΈ μ¬κ·€(recursive) μ•κ³ λ¦¬μ¦μ€ μ μ–΄λ„ $O(n)$μ κ³µκ°„ λ³µμ΅λ„λ¥Ό κ°–λ”λ‹¤!

\
